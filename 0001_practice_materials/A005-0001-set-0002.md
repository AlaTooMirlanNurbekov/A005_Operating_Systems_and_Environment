## Q100
Which scheduling algorithm gives priority to the process that arrives first?

a) SJF  
b) FCFS  
c) RR  
d) Priority  

--- answer: b

---

## Q101
Which algorithm minimizes the average waiting time for a known set of CPU burst lengths?

a) FCFS  
b) SJF  
c) RR  
d) Priority Scheduling  

--- answer: b

---

## Q102
A major drawback of **SJF** is:

a) It causes fragmentation  
b) It requires knowledge of future CPU burst lengths  
c) It never preempts  
d) It cannot run in multiprogrammed systems  

--- answer: b

---

## Q103
Which algorithm preempts the currently running process if a shorter job arrives?

a) FCFS  
b) SRTF  
c) RR  
d) Priority Scheduling  

--- answer: b

---

## Q104
In **Round Robin**, the CPU is assigned to processes:

a) Based on priority  
b) In arrival order without preemption  
c) In fixed time quantum cycles  
d) Only after all I/O is completed  

--- answer: c

---

## Q105
A very **large** time quantum in Round Robin makes the algorithm behave like:

a) SJF  
b) FCFS  
c) Priority Scheduling  
d) RR with better performance  

--- answer: b

---

## Q106
A very **small** time quantum in Round Robin results in:

a) Fewer context switches  
b) No preemption  
c) High context switching overhead  
d) Faster I/O  

--- answer: c

---

## Q107
Which scheduling algorithm could lead to **starvation** of low-priority processes?

a) FCFS  
b) RR  
c) Priority Scheduling  
d) SJF always prevents starvation  

--- answer: c

---

## Q108
What is **response time**?

a) Completion time − arrival time  
b) First time the process gets CPU − arrival time  
c) CPU burst time  
d) Waiting time + service time  

--- answer: b

---

## Q109
Which metric measures how many processes complete per unit time?

a) Response time  
b) Waiting time  
c) Turnaround time  
d) Throughput  

--- answer: d

---

## Q110
Which algorithm may suffer from the **convoy effect**?

a) SJF  
b) RR  
c) FCFS  
d) Priority Scheduling  

--- answer: c

---

## Q111
Which process gets CPU next in **Priority Scheduling**?

a) Lowest priority  
b) Highest priority  
c) Longest remaining time  
d) First to arrive  

--- answer: b

---

## Q112
A **preemptive** scheduling algorithm:

a) Never interrupts running processes  
b) Always completes one job fully before switching  
c) May interrupt a running process to give CPU to another  
d) Works only on multicore CPUs  

--- answer: c

---

## Q113
Turnaround time is:

a) Time waiting in ready queue  
b) Completion time − arrival time  
c) Time for first response  
d) CPU burst time  

--- answer: b

---

## Q114
Which scheduling method divides processes into different queues based on type or priority?

a) RR  
b) Multilevel queue scheduling  
c) SRTF  
d) FCFS  

--- answer: b

---

## Q115
What does a **time quantum** represent?

a) CPU clock frequency  
b) Memory page size  
c) Maximum time a process runs before forced context switch  
d) Number of processes in ready queue  

--- answer: c

---

## Q116
A process that first receives the CPU after waiting a long time has:

a) Low response time  
b) High response time  
c) Negative waiting time  
d) Higher throughput  

--- answer: b

---

## Q117
Which factor does the OS consider when selecting the next process?

a) Weather  
b) CPU scheduling policy  
c) GPU temperature  
d) File system format  

--- answer: b

---

## Q118
Starvation is prevented in priority scheduling by using:

a) Mutual exclusion  
b) Priority aging  
c) Time slicing  
d) Larger RAM  

--- answer: b

---

## Q119
Which scheduler decides **which ready process** runs next?

a) Long-term scheduler  
b) Medium-term scheduler  
c) Short-term scheduler  
d) Device scheduler  

--- answer: c

---

## Q120
A **critical section** is:

a) Part of code that loads GUI  
b) Code where shared data is accessed  
c) An OS bootloader  
d) A file on disk  

--- answer: b

---

## Q121
The main goal of synchronization is:

a) Increase frame rate  
b) Arrange files alphabetically  
c) Coordinate access to shared data  
d) Increase disk size  

--- answer: c

---

## Q122
A **race condition** occurs when:

a) Threads execute in alphabetical order  
b) Two or more threads modify shared data unpredictably  
c) System boots too quickly  
d) Hard disk fails  

--- answer: b

---

## Q123
Which of the following is **not** a requirement for a valid critical section solution?

a) Mutual exclusion  
b) Progress  
c) Bound waiting  
d) Unlimited CPU usage  

--- answer: d

---

## Q124
Which synchronization tool operates using **P() and V()** operations?

a) Switch  
b) Semaphore  
c) Thread group  
d) Page table  

--- answer: b

---

## Q125
A binary semaphore can have values:

a) Only negative  
b) Only 0 and 1  
c) 0 to 255  
d) Any number  

--- answer: b

---

## Q126
Which of the following is a **busy waiting** mechanism?

a) Blocking queue  
b) Monitor  
c) Spinlock  
d) Sleeping thread  

--- answer: c

---

## Q127
Deadlock occurs when:

a) CPU clock stops  
b) Each process in a set waits for a resource held by another  
c) Memory becomes full  
d) More processes arrive than CPU cores  

--- answer: b

---

## Q128
Which is **not** one of the four Coffman conditions for deadlock?

a) Mutual exclusion  
b) Hold and wait  
c) Circular wait  
d) First-come first-served  

--- answer: d

---

## Q129  
In deadlock **prevention**, the OS:

a) Tries to detect and recover  
b) Ensures at least one Coffman condition can never happen  
c) Ignores deadlocks  
d) Uses fragmentation  

--- answer: b

---

## Q130  
In deadlock **avoidance**, the OS:

a) Forces reboot  
b) Predicts if granting a request leads to unsafe state  
c) Kills all processes  
d) Deletes the file system  

--- answer: b

---

## Q131  
What does a **safe state** mean in the Banker’s Algorithm?

a) No deadlocks in OS  
b) OS can guarantee all processes can finish eventually  
c) All processes run at the same speed  
d) All processes share one resource  

--- answer: b

---

## Q132  
Which action may **recover** from deadlock?

a) Increase GPU speed  
b) Kill one or more processes  
c) Add more icons to desktop  
d) Rename directories  

--- answer: b

---

## Q133  
Deadlock **detection** involves:

a) Checking for cycles in resource allocation graph  
b) Increasing RAM  
c) Defragmenting disk  
d) Lowering CPU temperature  

--- answer: a

---

## Q134  
Starvation differs from deadlock because:

a) Starved process can eventually run; deadlocked cannot run at all  
b) Deadlock affects only I/O  
c) Starvation requires CPU overheating  
d) Deadlock happens only at boot  

--- answer: a

---

## Q135  
A **monitor** is:

a) Device that displays video  
b) A high-level synchronization structure with automatic locking  
c) A network device  
d) Hard drive controller  

--- answer: b

---

## Q136  
A **condition variable** is used to:

a) Pause and resume threads based on certain conditions  
b) Format disks  
c) Allocate memory pages  
d) Send network packets  

--- answer: a

---

## Q137  
Which best describes **hold and wait**?

a) Process holds CPU forever  
b) Process holds at least one resource and waits for another  
c) Process uses no memory  
d) Process runs faster than normal  

--- answer: b

---

## Q138  
Circular wait means:

a) Threads are executed in circular order  
b) A chain of processes where each waits for a resource held by the next  
c) CPU executes instructions in circles  
d) Disk head rotates circularly  

--- answer: b

---

## Q139  
Mutual exclusion means:

a) Only one process can modify shared resource at a time  
b) Processes never get CPU  
c) Only kernel can run  
d) Only one file exists in system  

--- answer: a

---

## Q140  
Bounded waiting ensures:

a) Each process waits forever  
b) A thread will eventually enter critical section  
c) Memory always stays below 50% usage  
d) Files never fragment  

--- answer: b

---

## Q141  
What does **preemption** mean in resource allocation?

a) Taking a resource away from a process  
b) Allocating extra RAM automatically  
c) Moving windows on screen  
d) Printing files faster  

--- answer: a

---

## Q142  
Which technique reduces the chance of deadlock?

a) All threads use resources in random order  
b) Assign a fixed ordering to resource requests  
c) Disable context switching  
d) Increase file system size  

--- answer: b

---

## Q143  
A semaphore value > 1 typically represents:

a) Binary semaphore  
b) Counting semaphore  
c) Error state  
d) No waiting allowed  

--- answer: b

---

## Q144  
Busy waiting wastes CPU time because:

a) Threads continuously check a condition without sleeping  
b) GPU is used for checking conditions  
c) Disk is formatted repeatedly  
d) Time quantum is infinite  

--- answer: a

---

## Q145  
Why are **mutexes** used?

a) To increase throughput  
b) To enforce exclusive access to shared resources  
c) To clear RAM  
d) To reorganize directories  

--- answer: b

---

## Q146  
Which of these is most likely to cause a **livelock** instead of a deadlock?

a) Two processes never release resources  
b) Processes keep changing state to avoid deadlock but make no progress  
c) Process terminates suddenly  
d) Disk becomes full  

--- answer: b

---

## Q147  
Which statement is true about **synchronization**?

a) It is only needed in single-thread systems  
b) Prevents inconsistent updates to shared data  
c) Eliminates the need for system calls  
d) Prevents OS scheduling  

--- answer: b

---

## Q148  
A deadlock may **not** occur if:

a) Mutual exclusion is present  
b) Circular wait is prevented  
c) Hold and wait is present  
d) No preemption is enforced  

--- answer: b

---

## Q149  
A thread waiting on a condition variable:

a) Spins in a tight loop  
b) Releases the lock and sleeps until signaled  
c) Terminates immediately  
d) Enters kernel mode permanently  

--- answer: b
